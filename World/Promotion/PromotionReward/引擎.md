# 引擎文件

## 目錄
1. [UserTags](#1-usertags)
2. [PromotionRules](#2-promotionrules)
3. [MatchedProcess](#3-matchedprocess)
4. [MismatchedProcess](#4-mismatchedprocess)
5. [排除商品](#5-排除商品)
6. [組合商品](#6-組合商品)
7. [攤提與QTY](#7-攤提與qty)
8. [圈商品結構](#8-圈商品結構)
9. [圈會員](#9-圈會員)
10. [圈Location](#10-圈location)
11. [促購前台發送](#11-促購前台發送)
12. [Thresholds結構](#12-thresholds結構)
13. [合併與獨立計算](#13-合併與獨立計算)
14. [關於僅 TS 攤提退款為甚麼消費者仍會拿到比較多得現象](#14-關於僅-ts-攤提退款為甚麼消費者仍會拿到比較多得現象)

<br>

---

## 1. UserTags

### 1.1 Cart API 的 GetUserTags 方法

Cart API 的 GetUserTags 方法會取得會員於購物車流程中的「會員標籤」，標籤將用於促銷引擎判斷目標對象（如：全會員、新會員、指定卡別會員）。

<br>

```csharp
/// <summary>
/// 取得會員標籤
/// </summary>
/// <param name="context">CartContext</param>
/// <param name="vipMember">VipMemberBriefDataEntity</param>
/// <returns>會員標籤</returns>
private string[] GetUserTags(CartContext context, VipMemberBriefDataEntity? vipMember)
{
    var userTags = new List<string>
    {
        PromotionEngineConstants.AllUserScope
    };

    if (context.Data.HasCrmShopContract == true)
    {
        userTags.Add($"{PromotionEngineConstants.CrmShopMemberCard}:{context.Data.CrmMemberTier.CrmShopMemberCardId}");
    }

    if (vipMember == null)
    {
        return userTags.ToArray();
    }

    if (vipMember.IsFirstPurchase)
    {
        userTags.Add(PromotionEngineConstants.FirstPurchase);
    }

    return userTags.ToArray();
}
```

<br>

📝 輸出範例

<br>

```json
["AllUserScope"]
```

<br>

```json
["AllUserScope", "CrmShopMemberCard:5"]
```

<br>

```json
["AllUserScope", "FirstPurchase"]
```

<br>

### 1.2 促購前台組成 Threshold

促購前台會根據 RewardPointRuleList 組成活動條件門檻（Threshold），以便促銷引擎在判斷是否給點時，依據不同會員卡分組進行。

<br>

```csharp
/// <summary>
/// 組成促購引擎規則
/// </summary>
/// <param name="promotionEngineId">PromotionEngine_Id</param>
/// <param name="entity">PromotionBaseEntity</param>
/// <returns>PromotionEngine_Rule Json String</returns>
public string GetPromotionEngineRule(long promotionEngineId, PromotionBaseEntity entity)
{
    //// 組成活動條件階層
    var thresholds = new Dictionary<string, RewardReachPriceWithPointThreshold>();

    //// 給點條件
    entity.RewardPointRuleList.ForEach(rewardPointRule =>
    {
        if (decimal.TryParse(rewardPointRule.Condition.ToString(), out var reachPrice) == false || rewardPointRule.Point == null)
        {
            throw new ApplicationException("活動折抵條件有誤");
        }

        var rewardReachPriceWithPointThreshold = new RewardReachPriceWithPointThreshold()
        {
            ReachPricePointPairs = new List<ReachPricePointPair>()
            {
                new ReachPricePointPair(reachPrice, rewardPointRule.Point.Value)
            }
        };

        //// 若 CrmShopMemberCardId = 0，代表活動適用全體會員
        var crmShopMemberCard = rewardPointRule.CrmShopMemberCardId == 0 ?
            nameof(AllUserScope) :
            $"CrmShopMemberCard:{rewardPointRule.CrmShopMemberCardId}";

        thresholds.Add(crmShopMemberCard, rewardReachPriceWithPointThreshold);
    });
}
```

<br>

📝 輸出範例

<br>

```json
{
  "AllUserScope": {
    "ReachPricePointPairs": [
      { "ReachPrice": 1000, "Point": 50 }
    ]
  },
  "CrmShopMemberCard:5": {
    "ReachPricePointPairs": [
      { "ReachPrice": 800, "Point": 80 }
    ]
  }
}
```

<br>

會員標籤（UserTags）與 Threshold Key 對應：前台組成 UserTags，後台 Thresholds 以相同 Tag 為 Key，促銷引擎在執行時做交集比對。

<br>

CrmShopMemberCardId = 0：代表適用所有會員，使用 AllUserScope。

<br>

---

## 2. PromotionRules

### 2.1 取用 this.Rules

- IsMatchedDate => 看活動的 Since / Until
- Enabled

<br>

### 2.2 Priority

Priority 看起來是有內定排序

<br>

### 2.3 IsSkipped

IsSkipped 在引擎有的 rule 會定義 skip RuleId

<br>

---

## 3. MatchedProcess

活動去 loop 這個購物車的商品

<br>

### 3.1 取得 threshold

<br>

### 3.2 GetMatchedProductScopeItems

IsInScope：確認 PurchaseItems 是否在 productItem.Tags 裡面 (TagProductScope)

<br>

OrderBy SalePrice

<br>

thenOrderBy PromotionEngineId

<br>

### 3.3 TotalPrice

TotalPrice = SalePrice 的 Sum

<br>

### 3.4 計算方式

**獨立計算**：Product.GroupKey 會是 TS，每一張 TS.SalessPrice * priceRateAndPointPair.Rate，最後 SUM 出這整張 TG 的 points

<br>

**合併計算**：TotalPrice 直接 * priceRateAndPointPair.Rate

<br>

### 3.5 產生 PromotionRecord

- PromotionId
- SourceType = Promotion
- Group = CartCalculate
- Point = 會有最大給點數的限制
- PurchasedItemIds
- NeedAmortization = no need to 攤提

<br>

---

## 4. MismatchedProcess

### 4.1 AddPromotionInstruction

#### 4.1.1 GetThreshold

<br>

#### 4.1.2 活動處理流程

有中活動找下一階，填上 DisplayHintInstruction 的：

<br>

- PromotionRuleId
- SourceType
- State = HintInfo

<br>

```json
{
  "LackSalesChannel": "位元處理",
  "LackOfPrice": "Math.Max(targetPair.ReachPrice - purchasedItemPrice, 0)",
  "Fulfilment": "targetPair"
}
```

<br>

#### 4.1.3 PurchaseItem 標記

每一個 purchaseItem 都有 Flags，要在沒中該活動的 purchaseItem 掛上對應 Promotion 的 TagsWhenMismatched

<br>

---

## 5. 排除商品

GetExcludePurchasedItems：把每一個排除的商品的 SalePrice 去移除 TotalPrice

<br>

---

## 6. 組合商品

- 組合商品會中只看組合商品 Major 本身是否被指定或排除
- 終究攤在下面
- 組合商品主商品沒有料號，不考慮此情境
- 子商品被排除也要整體有中並攤提

<br>

---

## 7. 攤提與QTY

討論串：https://91app.slack.com/archives/C089M6NLMN0/p1742201481723199

<br>

TG 給點公式：總商品實付金額 * 回贈匯率，無條件捨去

<br>

點數攤提公式：可得點數 * (商品實付金額 / 總商品實付金額)，若有餘數依序加在最後加入購物車的商品上

<br>

一個 TS 有多個 QTY，按照 QTY 攤提給了多少點數

<br>

攤提完無條件捨去

<br>

捨去的小數集合出來做第二輪的攤提

<br>

後加入的會先攤

<br>

須排除運費

<br>

攤到 QTY，餘數依序依"主單內交易序號最小的"加回 (CrmSalesOrderSlave_OuterOrderSlaveCode 小的)

<br>

---

## 8. 圈商品結構

```json
"IncludedProductScopes": [
  {
    "ProductScopeType": "NineYi.Msa.Tagging.TagProductScope",
    "Tag": "Collection:d_310414867779699456"
  },
  {
    "ProductScopeType": "NineYi.Msa.Tagging.TagProductScope",
    "Tag": "OuterIdTag:5847"
  }
]
```

<br>

**DB**

<br>

料號：PromotionTagSlave_TargetCode

<br>

---

## 9. 圈會員

```json
"MatchedUserScopes": [
  {
    "UserScopeType": "NineYi.Msa.Tagging.TagUserScope",
    "Tag": "CrmShopMemberCard:1"
  },
  {
    "UserScopeType": "NineYi.Msa.Tagging.TagUserScope",
    "Tag": "CrmShopMemberCard:2"
  }
]
```

<br>

---

## 10. 圈Location

```json
"IncludedLocationScopes": [
  {
    "LocationScopeType": "NineYi.Msa.Tagging.TagLocationScope",
    "Tag": 5848
  }
]
```

<br>

---

## 11. 促購前台發送

📌 促購引擎 SalepageSkuItemList 流程說明

<br>

☘️ CreateProcessContextAsync => ProcessContext.SalepageSkuItemList

<br>

| 欄位名稱 | 說明 |
|---------|------|
| SalepageId | 銷售頁編號 |
| OuterId | 商品外部編號（SKU） |
| Price | 單筆價格 |
| Tags | 促購標籤（Collection:f_xxxx） |

<br>

🧪 計算前 CreateShoppingCartContext，建立 productItem，引擎會 Mapping 成 purchasedItem

<br>

```csharp
CreateShoppingCartContext

//// 將 CollectionId 貼到 SalePage 上面同時將商品資料加入購物車
foreach (var item in context.SalepageSkuItemList)
{
    var productItem = new ProductItem
    {
        Id = item.SalepageId,
        SkuId = item.SkuId,
        ListPrice = item.Payment,
        Tags = item.Tags,
        CartId = item.CartId,
        CartExtendInfoItemType = item.CartExtendInfoItemType,
        CartExtendInfoItemGroup = item.CartExtendInfoItemGroup,
        CartExtendInfos = item.CartExtendInfos.Select(i => new CartExtendInfo
        {
            RuleTypeDef = i.RuleTypeDef,
            RuleId = i.RuleId,
            RelatedItemCartIds = i.RelatedItemCartIds,
            RelatedSubItemCount = i.RelatedSubItemCount
        })
    };

    ISet<string> flags = item.Flags.ToHashSet();
    shoppingCartContext.Purchase(item.Index, productItem, flags);
}
```

<br>

**Purchase**

<br>

ProductItem 賦值給 PurchasedItem

<br>

TotalPrice += purchasedItem.SalePrice

<br>

SalePrice = item.ListPrice

<br>

🛒 Saleapge Collection 貼標

<br>

**API**：api/salepage-collections:match

<br>

**Response**

<br>

```
List<SalepageCollectionMapping> Mapping
    SalepageId long
    Matched List<SalepageCollectionMatched>
        - PromotionEngineId
        - SalepageCollectionId
        - SourceId (商品加價購在用)
```

<br>

```csharp
GetMatchedSalepageCollectionAsync (每個 salepage 對應多個 Tags => 進到引擎)
salepageIdList 打 GetMatchedSalepageCollectionAsync (api/salepage-collections:match)

var match = await this._collectionHttpClient.GetMatchedSalepageCollectionAsync(
    new GetMatchedSalepageCollectionRequest
    {
        SalepageIds = idList,
        MatchType = nameof(GetMatchedSalepageCollectionRequestMatchTypeEnum.FilterByPromotions),
        ExpectedPromotionsOnActiveTime = this.GetDateTimeNow(),
        ExpectedPromotionsExtentDurationSeconds = config.ExtentDurationSeconds, //// 多取 30min 後要開始的活動
    },
    this._collectionHttpClient.GetRequestHeaders(context.ShopId));

組織成：salepageId：對應的 match 資料們(tag / promotionId / salepageId)
```

<br>

☘️ 料號貼標 GetOuterIdTagsAsync

<br>

這段期間有中的活動拉出來的 tag 拉出他們的 typecode (PromotionTag SQL DB) & salesProduct (S3)

<br>

比對現在手上的 SalepageSkuItemList.OuterId 看有沒有中

<br>

🐧 LoadRules 會把資料 Mapping 進去引擎

<br>

```csharp
//////// 各 rule 實作的 PromotionEngineRule
dynamic jsonRuleObject = this.GetRuleObject(typeof(RewardReachPriceWithRatePoint2).FullName, promotionEngineId, entity);
var ruleList = context.ProcessRuleList.SelectMany(i => i.RuleList).ToList();
result.TypeFullName = typeFullName;
result.Id = promotionEngineId;
result.Name = entity.Name;
result.Enabled = true;
result.Description = entity.Description;
result.Since = entity.StartDateTime;
result.Until = entity.EndDateTime;
result.UpdatedAt = this.GetDateTimeNow();
result.Cyclable = entity.IsCyclable;
result.Accumulated = entity.Accumulated;
result.IncludedProductScopes = this._includedProductScopes;
result.ExcludedProductScopes = this._excludedProductScopes;
result.IncludeRegionScopes = this._includeRegionScopes;
result.MatchedUserScopes = this._matchedUserScopes;
result.VisibleUserScopes = this._visibleUserScopes;
result.MatchedSalesChannels = (int)SalesChannelAdapter.ToSalesChannelEnum(entity.TargetPlatformTypeList);
result.VisibleSalesChannels = (int)SalesChannelAdapter.ToSalesChannelEnum(this.GetVisiblePlatformTypeList(entity));
result.IncludedLocationScopes = this._includedLocationScopes;
_promotionEngine.LoadRules(RuleLoader.AssemblyFullName, ruleList.Select(i => i.Rule).ToList());
this.SerializePromotionRule(jsonRuleObject);

//////// 在計算前
LoadRuleAndModifyPriority
_promotionEngine.LoadRules(RuleLoader.AssemblyFullName, ruleList.Select(i => i.Rule).ToList());
```

<br>

🎀 計算入口點

<br>

EngineCalculate

<br>

準備 ShoppingCartContext ⇒ 送到 NineYi.Msa.Promotion.Engine.ProcessPromotion

<br>

---

## 12. Thresholds結構

依照等級給予門檻不同

<br>

```json
"CrmShopMemberCard:5": {
  "ReachPricePointPairs": [
    {
      "ReachPrice": 123.0,
      "Point": 33.0
    }
  ]
}
```

<br>

**Coupon**

<br>

```json
{
  "Thresholds": {
    "CrmShopMemberCard:30": {
      "ReachPriceCouponPairs": [
        {
          "ReachPrice": 1.0,
          "Coupons": [
            {
              "Id": "1865",
              "Qty": 1
            }
          ]
        }
      ]
    },
    "CrmShopMemberCard:31": {
      "ReachPriceCouponPairs": [
        {
          "ReachPrice": 1.0,
          "Coupons": [
            {
              "Id": "1865",
              "Qty": 1
            }
          ]
        }
      ]
    },
    "CrmShopMemberCard:32": {
      "ReachPriceCouponPairs": [
        {
          "ReachPrice": 1.0,
          "Coupons": [
            {
              "Id": "1865",
              "Qty": 1
            }
          ]
        }
      ]
    }
  }
}
```

<br>

---

## 13. 合併與獨立計算

**合併計算 TG**：PointCalculateType：RewardPointCalculateType.Merged

<br>

**獨立計算 TS**：RewardPointCalculateType.Independent

<br>

---

## 14. 關於僅 TS 攤提退款為甚麼消費者仍會拿到比較多得現象

<br>

**VSTS 連結**：https://91appinc.visualstudio.com/G11n/_workitems/edit/498163

<br>

**案例資訊**

<br>

- Shop：11
- Member：98330069 / 123456
- TG：TG250606T00002

<br>

該筆訂單有3個TS，金額及訂單狀態如下：

<br>

- TS250606T000002 > 訂單已取消(HK$ 77)
- TS250606T000003 > 已成立 (HK$999.99)
- TS250606T000004 > 訂單已取消 (HK$ 199.8)

<br>

**活動分析**

<br>

有中以下幾個活動，理論應只算TS250606T000003要給多少點，預期如下：

<br>

- (7041)滿199，6/8就給50%點數：499點
- (7039)滿100指定6/8給100點，可循環：900點

<br>

目前是給：

<br>

- (7041)滿199，6/8就給50%點數：500點
- (7039)滿100指定6/8給100點，可循環：940點

<br>

**觀念說明**

<br>

👉 你因為「曾有其他人加成」，現在雖然他們走了，你卻「獨享」獎勵，所以會變多(在「計算總點數」的當下，還是有幫你「墊高整體滿額次數」！)

<br>